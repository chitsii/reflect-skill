---
description: セッションから学習を抽出して知識ファイルに記録
---

# /reflect-skill:reflect

セッションを分析し、**ユーザーによる修正**を `.reflect/knowledge/` に記録。

## 知識の定義

**知識 = ユーザーがClaudeの出力を「修正」した内容**

| 知識である | 知識ではない |
|-----------|-------------|
| 「〜に変えて」 | 「OK」「いいね」 |
| 「〜しないで」 | 「全てOKです」 |
| 「必ず〜を使って」 | 「そのままで」 |
| 「違う、〜だ」 | 単なる質問 |
| 「毎回〜して」 | 情報の提供 |
| 「常に〜で」 | **通常の作業依頼** |

### 通常の作業依頼は知識ではない

強調語（必ず/絶対/常に/毎回など）を含まない作業依頼は、そのタスク固有の指示であり、知識として記録しない。

| 通常の作業依頼（除外） | 知識（記録対象） |
|----------------------|-----------------|
| 「ログイン機能を作って」 | 「ログイン機能は**必ず**2FAを含めて」 |
| 「このファイルを修正して」 | 「修正時は**常に**テストも更新して」 |
| 「APIを呼び出して」 | 「APIは**絶対に**try-catchで囲んで」 |
| 「コンポーネントを追加して」 | 「コンポーネントは**毎回**Storybookも作って」 |

**判定基準**: 強調語がなければ、それは「今回のタスク」への指示であり、「今後すべてのタスク」への指示ではない。

**目的**: ユーザーによる修正が蓄積され、開発体験を潤滑化すること

## 実行手順

### Step 1: セッション分析
会話履歴をスキャンし、**ユーザーによる修正**を検出:

#### High（明示的指示）
**検出パターン:**
- 強制: 「必ず」「絶対に」「常に」「毎回」「例外なく」
- 禁止: 「〜するな」「〜しないで」「〜禁止」「〜NG」「〜やめて」
- 修正指示: 「〜に変えて」「〜を使って」「〜にして」（2回以上）
- 明示的ルール: 「ルール:」「規約:」「必須:」

**例:**
- 「Buttonは必ずshadcnから使って」→ High
- 「console.logは使わないで」→ High
- 「このプロジェクトではTypeScriptを使う」→ High

#### Medium（修正指示）
**検出パターン:**
- 好みの修正: 「〜がいい」「〜の方がいい」「〜にして」
- 軽微な修正: 「ちょっと違う」「〜も追加して」
- 1回の指摘: 同じ修正が1回のみ

**例:**
- 「Result型を使う方がいい」→ Medium（好みの修正）
- 「ここは〜にして」→ Medium（軽微な修正）

**知識ではない（除外）:**
- 「OK」「いいね」「それでいい」（単なる承認）
- 「全てOKです」（修正なしの承認）
- 「そうそう」（確認のみ）
- 通常の作業依頼（強調語なし）

#### Low（暗黙の修正）
**検出パターン:**
- 暗黙の好み: 明示的に言わないが、特定の選択を繰り返す
- 文脈依存の修正: 「今回は〜で」（次回は異なる可能性）

**例:**
- 複数回、特定のライブラリを選択 → Low（暗黙の好み）
- 「今回は〜で」→ Low（文脈依存）

**知識ではない（除外）:**
- Claudeの推測（ユーザーの修正がない）
- 単なる観察（修正に繋がっていない）

### Step 2: 重複・競合検出（Subagent）

**呼び出し条件**: Step 1 で知識が **1件以上** 検出された場合

```
if (検出された知識 >= 1件) {
  → Subagent を起動
} else {
  → 「検出された学習: 0件」を報告して終了
}
```

Task tool で重複・競合検出を実行:

```
Task tool:
  subagent_type: "Explore"
  model: "haiku"
  description: "知識の重複・競合検出"
  prompt: |
    新しい知識を既存知識と比較し、重複・競合を検出してください。

    ## 新しい知識
    {{Step 1 で検出した知識リスト}}

    ## 検索手順
    1. `.reflect/knowledge/high/` の全ファイルを読む
    2. `.reflect/knowledge/medium/` の全ファイルを読む
    3. 各新知識について以下をチェック:
       - 同一トピック: 既存知識と同じ主題か
       - 矛盾: 既存知識と矛盾しないか
       - 上位互換: 既存知識を包含するか

    ## 出力形式
    📋 重複・競合チェック結果

    [1] {{知識タイトル}}
    状態: 新規 / 重複 / 競合 / 上位互換
    既存: {{競合する既存知識があれば記載}}
    推奨: 追加 / マージ / 上書き / スキップ

    [2] ...
```

**結果の分類:**
| 状態 | 意味 | 次のアクション |
|------|------|---------------|
| 新規 | 既存に類似なし | → Step 4 で追加提案 |
| 重複 | 既存と同一 | → スキップ（追加不要） |
| 競合 | 既存と矛盾 | → Step 3 でマージ提案 |
| 上位互換 | 既存を包含 | → Step 4 で上書き提案 |

### Step 3: マージ提案（Subagent）

**呼び出し条件**: Step 2 で **競合** が検出された場合のみ

```
if (競合あり) {
  → 競合する知識ごとに Subagent を起動
} else {
  → Step 4 へスキップ
}
```

Task tool でマージ案を生成:

```
Task tool:
  subagent_type: "Explore"
  model: "haiku"
  description: "知識のマージ提案"
  prompt: |
    競合する知識をマージしてください。

    ## 既存知識
    ファイル: {{ファイルパス}}
    内容: {{既存の知識内容}}

    ## 新しい知識
    内容: {{新しい知識内容}}

    ## マージ方針
    - 両方の意図を活かす
    - 矛盾する場合は条件分岐で表現（例: 「基本は〜、ただし〜の場合は〜」）
    - 簡潔さを維持

    ## 出力形式
    📝 マージ提案

    **マージ後:**
    {{統合された知識内容}}

    **変更点:**
    - {{何を追加/変更したか}}
```

### Step 4: 更新提案
検出シグナルと競合チェック結果を元に、更新内容を提案:

```
📝 検出された学習 (3件)

[High] UI規約
  内容: Buttonはshadcnから使用
  競合: なし
  → high/main.md に追加

[Medium] エラー処理
  内容: Result型でエラーを返す
  競合: 既存「try-catchを使う」と矛盾
  マージ案: 「基本はResult型、外部API呼び出しはtry-catch」
  → マージ/上書き/スキップ?

[Low] 命名傾向
  内容: ハンガリアン記法を避ける傾向
  競合: なし
  → low/main.md に追加
```

### Step 5: ユーザー確認（手動モード）または自動適用（自動モード）

**手動モード（デフォルト）:**
- Y: 全て適用
- 数字: 個別に確認（例: "2" で2番目を詳細表示）
- 自然言語: 修正指示
- N: キャンセル

**自動モード（`autoMaintenance: true`）:**
- 新規・上位互換 → 自動追加
- 重複 → 自動スキップ
- 競合 → マージ案を自動適用

### Step 6: 適用
1. `.reflect/knowledge/` 内のファイルを更新
2. `_index.md` を更新（medium/low）
3. `config.json` の `lastReflect` を更新
4. Git commit & push（リモートがあれば）

## 知識ファイルの場所
- `.reflect/knowledge/high/` - 常に読む
- `.reflect/knowledge/medium/` - 関連時に検索
- `.reflect/knowledge/low/` - アーカイブ

## 知識とドキュメントの責務分離

### 設計の「詳細」vs「方針」

| 設計詳細（DESIGN.md の責務） | 設計方針（知識として記録） |
|----------------------------|-------------------------|
| 「認証はJWTで実装する」 | 「認証は**常に**セキュリティファーストで考えて」 |
| 「DBはPostgreSQLを使用」 | 「DB選定は**必ず**スケーラビリティを優先して」 |
| 「マイクロサービス構成にする」 | 「アーキテクチャは**毎回**テスト容易性を重視して」 |
| 「APIはREST形式で設計」 | 「API設計は**絶対に**後方互換性を維持して」 |

**判定基準**:
- **What（何を）**: 具体的な技術選定・構成 → DESIGN.md
- **How（どのように考えるか）**: 設計時の価値観・優先事項 → 知識

### 不変のルール vs 学習した知識

| 不変のルール（CLAUDE.md の責務） | 学習した知識（.reflect/） |
|-------------------------------|-------------------------|
| プロジェクト固有の技術スタック | ユーザーの好みや癖 |
| チーム全体で守るべき規約 | 個人的なこだわり |
| リポジトリ構成の説明 | セッション中に指摘された改善点 |

**判定基準**:
- **誰が決めたか**: プロジェクト/チーム → CLAUDE.md
- **誰が決めたか**: このユーザー個人 → 知識

## 自動メンテナンスモード

### 設定

`config.json` に追加:
```json
{
  "autoMaintenance": true
}
```

### 動作

`autoMaintenance: true` の場合:
- **Compact時**に自動でreflectを実行
- 親セッションが知識の追加・変更を判断
- ユーザー確認なしで適用

### 推奨タイミング

| タイミング | モード | 理由 |
|-----------|--------|------|
| Compact前 | 自動 | 詳細な会話履歴が残っているうちに抽出 |
| セッション終了時 | 手動 | 最終確認として |

### 制限事項

**Compact後の制限:**
- 要約により詳細な修正指示が失われる可能性
- 強調語（「必ず」「絶対」など）のニュアンスが消える場合あり
- → Compact前にreflectを実行することを推奨

## 注意
- 200行以内を維持
- 自動モードでも競合時はマージ案を自動適用（不安な場合は手動モード推奨）
