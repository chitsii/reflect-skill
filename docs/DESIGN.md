# Self-Improving Skills System 設計書

## 1. 概要

Claude Codeにおいて、セッション間で学習を持続させる「自己改善スキル」システムを構築する。LLMはセッションごとに記憶がリセットされるため、同じ修正を何度も繰り返す必要がある問題を解決する。

## 2. 課題（解決すべき問題）

### 2.1 現状の問題点

| 問題 | 具体例 |
|------|--------|
| 記憶の欠如 | 前回セッションで指示した内容を覚えていない |
| 繰り返しの修正 | ボタンスタイル、命名規則、ログ規約を毎回指摘 |
| 一貫性の欠如 | 入力検証の方法がコンポーネント間で不統一 |
| ユーザーの疲弊 | 「昨日も言ったのに...」というフラストレーション |

### 2.2 影響範囲

- 全てのLLMモデルに共通する問題
- 全てのコーディングハーネスに共通する問題
- 開発効率の低下とユーザー体験の悪化

## 3. ソリューション概要

**コンセプト**: セッション終了時（または手動トリガー時）に会話を分析し、修正パターンと成功パターンを抽出してスキルファイルに永続化する。

### 3.1 主要機能

1. **Reflect（リフレクション）機能**
   - 会話を分析して学習シグナルを検出
   - スキルファイルを自動更新
   - Git連携によるバージョン管理

2. **操作モード**
   - **手動モード**: `/reflect` コマンドで明示的に実行
   - **自動モード**: Stop Hookで自動トリガー
   - **ハイブリッドモード**: トグルで切り替え可能

## 4. システムアーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                    Claude Code Session                       │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐  │
│  │   ユーザー   │───▶│   Claude    │───▶│   修正/     │  │
│  │    入力      │    │   応答      │    │   承認      │  │
│  └──────────────┘    └──────────────┘    └──────────────┘  │
│           │                                      │          │
│           └──────────────┬───────────────────────┘          │
│                          ▼                                   │
│              ┌───────────────────────┐                      │
│              │   学習シグナル蓄積    │                      │
│              └───────────────────────┘                      │
│                          │                                   │
└──────────────────────────┼───────────────────────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │ Trigger          │                   │
        │                  ▼                   │
        │  ┌───────────────────────────────┐  │
        │  │      Reflect Skill            │  │
        │  ├───────────────────────────────┤  │
        │  │ 1. 会話スキャン               │  │
        │  │ 2. シグナル抽出               │  │
        │  │ 3. 信頼度分類                 │  │
        │  │ 4. スキル更新提案             │  │
        │  │ 5. ユーザー承認               │  │
        │  │ 6. Git コミット & プッシュ    │  │
        │  └───────────────────────────────┘  │
        │                  │                   │
        └──────────────────┼───────────────────┘
                           ▼
        ┌───────────────────────────────────────┐
        │           Knowledge Directory         │
        │  ┌─────────────────────────────────┐  │
        │  │ high/main.md                    │  │
        │  │ medium/main.md                  │  │
        │  │ low/main.md                     │  │
        │  └─────────────────────────────────┘  │
        └───────────────────────────────────────┘
```

## 5. コンポーネント詳細

### 5.1 学習シグナルの種類

| 信頼度 | シグナルタイプ | 説明 | 例 |
|--------|---------------|------|-----|
| **High** | 明示的指示 | ユーザーが「絶対に〜するな」「必ず〜しろ」と指示 | 「このプロジェクトでは独自のボタンスタイルを使うな」 |
| **Medium** | 成功パターン | うまくいった実装パターン | SQLインジェクションチェックの追加で承認された |
| **Low** | 観察事項 | 後で確認すべき傾向 | 特定のライブラリを好む傾向がある |

### 5.2 Reflect Skill 処理フロー

1. 会話履歴をスキャン
2. 修正イベントを検出（ユーザーの指摘・訂正）
3. 承認イベントを検出（ユーザーの肯定・承認）
4. シグナルを信頼度で分類
5. 関連知識ファイルを特定
6. 更新提案を生成
7. ユーザーに確認（手動モードの場合）
8. 知識ファイルを更新
9. Git でコミット＆プッシュ

### 5.3 コマンド

| コマンド | 説明 |
|----------|------|
| `/reflect-skill:on` | 自動リフレクションを有効化 |
| `/reflect-skill:off` | 自動リフレクションを無効化 |
| `/reflect-skill:status` | 現在の状態を表示 |
| `/reflect-skill:reflect` | 手動でリフレクションを実行 |
| `/reflect-skill:split` | 200行超えファイルを分割 |

### 5.4 Hook 連携

```json
// settings.json (Claude Code)
{
  "hooks": {
    "stop": {
      "command": "./scripts/reflect.sh",
      "enabled": true
    }
  }
}
```

## 6. データフロー

### 6.1 手動フロー

```
ユーザー → /reflect 実行
         ↓
   会話コンテキスト取得
         ↓
   シグナル抽出・分類
         ↓
   更新提案を表示
         ↓
ユーザー → 承認/修正/拒否
         ↓
   知識ファイル更新
         ↓
   Git commit & push
         ↓
   完了通知
```

### 6.2 自動フロー

```
セッション終了 → Stop Hook 発火
              ↓
        reflect.sh 実行
              ↓
        シグナル抽出・分類
              ↓
        知識ファイル更新
              ↓
        Git commit & push
              ↓
        サイレント通知
```

## 7. 知識ファイル構造

**制約: 1ファイル200行以内、簡潔に記述**

```markdown
# Code Review
<!-- confidence: high | updated: 2024-01-20 -->

## Must Check
- SQLi, XSS対策
- 入力検証
- エラーハンドリング

## Project Rules
- Button: `@/components/ui/button` から (high)
- Logger: `winston` 使用 (medium)

## NG Pattern
- 生SQL文字列連結
- any型の多用
```

## 8. 設計決定事項

| 項目 | 決定 | 理由 |
|------|------|------|
| **配置場所** | プロジェクトローカル（`.reflect/`） | プロジェクト固有の学習を保持 |
| **Git連携** | 自動コミット＋自動プッシュ | 変更を即座にリモートに反映 |
| **デフォルト状態** | OFF（手動推奨） | 動作確認後に有効化を推奨 |
| **統合方法** | 独立したプラグインとして作成 | 他のシステムに依存しない |

## 9. 考慮事項

### 9.1 利点

- **シンプルさ**: Markdownファイルベースで複雑なDB/埋め込み不要
- **可視性**: Gitで変更履歴を追跡可能
- **ポータビリティ**: プロジェクト間でスキルを共有可能
- **可読性**: 自然言語で記述されているため理解しやすい

### 9.2 注意点

- 自動モードは信頼性が確立されてから使用推奨
- 誤った学習が蓄積するリスクへの対策が必要
- 知識ファイルの肥大化防止策が必要

### 9.3 将来の拡張可能性

- 複数プロジェクト間でのスキル共有
- チーム共有知識とパーソナル知識の分離
- 学習内容の品質スコアリング
- 古い/非推奨の学習内容の自動アーカイブ
